函数定义需要在调用前，也就是说调用时，已经被定义过了，否则抛NameError异常
函数是可调用的对象，callable()  
  callable(add)  # true

函数参数
  要求位置参数必须在关键字参数之前传入，位置参数是按位置对应的

  参数默认值
    默认缺省值需要放在位置参数后面
      def add(x=4, y=5):
        return x+y
      add(x=5, 6) # 报错

  位置参数的可变参数
    在形参前使用*表示该形参是可变参数，可以接收多个实参
    收集多个实参为一个tuple
    可变位置参数不可以用关键字传参
  关键字参数的可变参数
    形参前使用**符号，表示可以接收多个关键字参数
    收集的实参名称和值组成一个字典

  总结
    有位置可变参数和关键字可变参数
    位置可变参数在形参前使用一个星号* 
    关键字可变参数在形参前使用两个星号** 
    位置可变参数和关键字可变参数都可以收集若干个实参，位置可变参数收集形成一个tuple，关键字可变参数收集形成一个dict 
    混合使用参数的时候，可变参数要放到参数列表的最后，普通参数需要放到参数列表前面，位置可变参数需要在关键字可变参数之前

    def fn(x, y, *args, **kwargs):
      pass
    fn(7,9,y=5,x=3,a=1,b='python') # 错误，7和9分别赋给了x，y，又y=5、x=3，重复了

  keyword-only参数(Python3加入）  
    如果在一个星号参数后，或者一个位置可变参数后，出现的普通参数，实际上已经不是普通的参数了，而是keyword-only参数

    def fn(*args, x, y, **kwargs): # 这样定义是可以的,此时x和y为keyword-only参数
      pass
    fn(7,9,y=5,x=3,a=1,b='python')

    keyword-only 参数另一种形式
      *号之后，普通形参都变成了必须给出的keyword-only参数, *号本身没有什么意义只是为了构造后面的keyword-only
      def fn(*, x,y):
        print(x,y) 
      fn(x=5,y=6) 

  参数规则
    参数列表参数一般顺序是，普通参数、缺省参数、可变位置参数、keyword-only参数（可带缺省值）、可变关键字参数
      def fn(x, y, z=3, *arg, m=4, n, **kwargs):
        print(x,y,z,m,n) 
        print(args) 
        print(kwargs)

参数解构
  给函数提供实参的时候，可以在集合类型前使用*或者**，把集合类型的结构解开，提取出所有元素作为函数的实参
  非字典类型使用*解构成位置参数
  字典类型使用**解构成关键字参数
  提取出来的元素数目要和参数的要求匹配，也要和参数的类型匹配

  def add(x, y):
    return x+y 
  add(*(4,5))
  d = {'x': 5, 'y': 6} 
  add(**d) # 11
  add(**{'a': 5, 'b': 6}) # 报错 等于是add(a=5, b=6)
  add(*{'a': 5, 'b': 6})' # 'ab'

  参数解构和可变参数
    给函数提供实参的时候，可以在集合类型前使用*或者**，把集合类型的结构解开，提取出所有元素作为函数的实参

    def add(*iterable):
      result = 0
      for x in iterable:
        result += x
      return result 
    add(1,2,3) 
    add(*[1,2,3]) 
    add(*range(10))
  
