辅助网站
  https://play.rust-lang.org/?version=stable&mode=debug&edition=2021
  https://doc.rust-lang.org/std/index.html
  https://doc.rust-lang.org/book/title-page.html
  https://doc.rust-lang.org/rust-by-example/index.html

创建一个工程
  cargo new --bin helloworld 
  cargo build
  cargo build —release
  cargo run
  cargo run —release

  cargo check 编译检查

Hello, World
  fn main() {
    println!("Hello, world!");
  }

赋值
  fn main() {
    let a: u32 = 1;
  }

数字类型
  长度    有符号   无符号
  8-bit  i8       u8
  16-bit i16      u16
  32-bit i32      u32
  64-bit i64      u64
  128-biti128     u128
  arch   isize    usize

整数字面量
  Number literals    Example
  Decimal            98_222
  Hex                0xff
  Octal              0o77
  Binary             0b1111_0000
  Byte (u8 only)     b'A'

浮点数
  f32
  f64

布尔类型
  bool: true or false

字符 char
  https://doc.rust-lang.org/std/primitive.char.html
  char占4个字节
  fn main() {
    let c = 'z';
    let z: char = 'ℤ'; 
  }

字符串 String
  String内部存储的Unicode字符串的UTF8编码。

  let s = String::from("initial contents");
  let hello = String::from("ﻼﺴﻟﺎﻣ ﻊﻠﯿﻜﻣ");
  let hello = String::from("Dobrý den");
  let hello = String::from("Hello");
  let hello = String::from("こんにちは");
  let hello = String::from("안녕하세요");
  let hello = String::from("你好");

字符串不能使用索引操作
  注意：Rust中的String不能通过下标去访问：
  let hello = String::from("你好");
  let a = hello[0]; // 你可能想把“你”字取出来，但实际上这样是错误的因为String存储的UTF8编码，这样访问即使能成功，也只能取出一个字符的UTF8
  编码的一部分，其是没有意义的。因此Rust直接对String禁止了这个索引操作。

  error[E0277]: the type `String` cannot be indexed by `{integer}`

字符串字面量中的转义
  fn main() {
    let byte_escape = "I'm writing \x52\x75\x73\x74!";

    println!("What are you doing\x3F (\\x3F means ?) {}", byte_escape);

    let unicode_codepoint = "\u{211D}";

    let character_name = "\"DOUBLE-STRUCK CAPITAL R\"";
    println!("Unicode character {} (U+211D) is called {}", unicode_codepoint, character_name );
    let long_string = "String literals 
                      can span multiple lines.
                      The linebreak and indentation here ->\
                      <- can be escaped too!";
    println!("{}", long_string);
  }

禁止转义
  fn main() {
    let raw_str = r"Escapes don't work here: \x3F \u{211D}";
    println!("{}", raw_str);

    let quotes = r#"And then I said: "There is no escape!""#;
    println!("{}", quotes);

    let longer_delimiter = r###"A string with "# in it. And even "##!"###;
    println!("{}", longer_delimiter);
  }

字节串
fn main() {
  let bytestring: &[u8; 21] = b"this is a byte string";
  println!("A byte string: {:?}", bytestring);

  let escaped = b"\x52\x75\x73\x74 as bytes";
  println!("Some escaped bytes: {:?}", escaped);

  let raw_bytestring = br"\u{211D} is not escaped here";
  println!("{:?}", raw_bytestring);

  let _quotes = br#"You can also use "fancier" formatting, \
                    like with normal raw strings"#;
  let shift_jis = b"\x82\xe6\x82\xa8\x82\xb1\x82\xbb"; // "ようこそ" in SHIFT-JIS
}

数组 - 定长数组
  fn main() {
    let a: [i32; 5] = [1, 2, 3, 4, 5];
    let a = [1, 2, 3, 4, 5];
    let months = ["January", "February", "March", "April", 
    "May", "June", "July", "August", "September", "October", 
    "November", "December"];
  }

下标索引数组元素
  fn main() {
    let a: [i32; 5] = [1, 2, 3, 4, 5];
    let b = a[0];
    println!("{}", b)
  }

数组 - 动态数组
  let v: Vec<i32> = Vec::new();
  let v = vec![1, 2, 3];
  let mut v = Vec::new();
  v.push(5);
  v.push(6);
  v.push(7);
  v.push(8);

下标索引动态数组
  fn main() {
    let v = vec![1, 2, 3];
    let a = v[0];
  }
  fn main() {
    let v = vec![1, 2, 3];
    let a = v[3]; // 运行时报错
  }

哈希表
  use std::collections::HashMap;
  let mut scores = HashMap::new();
  scores.insert(String::from("Blue"), 10);
  scores.insert(String::from("Yellow"), 50);
  println!(“{:?}”, scores);

元组
  fn main() {
    let tup: (i32, f64, u8) = (500, 6.4, 1);
  }
  fn main() {
    let x: (i32, f64, u8) = (500, 6.4, 1);
    let five_hundred = x.0;
    let six_point_four = x.1;
    let one = x.2;
  }

结构体
  struct User {
    active: bool,
    username: String,
    email: String,
    age: u64,
  }

枚举
  enum IpAddrKind {
    V4,
    V6,
  }
  let four = IpAddrKind::V4;
  let six = IpAddrKind::V6;

分支语句 if else 
  let number = 6;
    if number % 4 == 0 {
    println!("number is divisible by 4");
  } else if number % 3 == 0 {
    println!("number is divisible by 3");
  } else if number % 2 == 0 {
    println!("number is divisible by 2");
  } else {
    println!("number is not divisible by 4, 3, or 2");
  }

if else 其实可以返回值
  fn main() {
    let x = 1;
    let y = if x == 0 {
      100
    } else {
      101
    };
    println!("y is {}", y);
  }

循环语句 loop, while, for
  fn main() {
    let mut counter = 0;
    let result = loop {
      counter += 1;
      if counter == 10 {
        break counter * 2;
      }
    };
    println!("The result is {result}");
  }

while
  fn main() {
    let mut number = 3;
    while number != 0 {
      println!("{number}!");
      number -= 1;
    }
    println!("LIFTOFF!!!");
  }

for
  fn main() {
    let a = [10, 20, 30, 40, 50];
    for element in a {
      println!("the value is: {element}");
    }
  }

range ..
  https://doc.rust-lang.org/std/ops/struct.Range.html

  fn main() {
    for number in 1..4 {
      println!("{number}");
    }
    for number in 1..=4 {
      println!("{number}");
    }
    for number in (1..4).rev() {
      println!("{number}");
    }
  }

range a..z
  fn main() {
    for ch in 'a'..='z' {
      println!("{ch}");
    }
  }

  https://play.rust-lang.org/?version=stable&mode=debug&edition=2021&gist=7ec48585c881acee685a6c33dda94dec

函数 fn
  fn print_a_b(value: i32, unit_label: char) {
    println!("The value of a b is: {value}{unit_label}");
  }

  fn main() {
    print_a_b(5, 'h');
  }

模块
  backyard
  ├── Cargo.lock
  ├── Cargo.toml
  └── src
    ├── garden
    │ └── vegetables.rs
    ├── garden.rs
    └── main.rs

模块的另一种组织形式
  backyard
  ├── Cargo.lock
  ├── Cargo.toml
  └── src
    ├── garden
    │ └── mod.rs
    │ └── vegetables.rs
    └── main.rs
  
Cargo.toml
  https://doc.rust-lang.org/cargo/
  https://github.com/hyperium/hyper/blob/master/Cargo.toml