占位符使用
    %[标志][宽度]类型

    类型
    %d %i 整形
    %f 单精度
    %lf 双精度
    %c 字符型
    %o 以八进制输出
    %x 以16进制输出
    %p 变量地址
    %u 用无符号方式取出
    %s 字符串,会从数组的第0个元素开始打印,直到遇到\0为止

    指定宽度
    %5i // 指定5位

    标志
    + 当输出为正数时,在输出值前面加上1个+号,默认不显示
    - 左对齐，默认右对齐
    0 右对齐时,用0填充宽度(默认用空格填充)
    空格 输出值为正数时,在输出值前面加上空格,为负数时加上负号

    精度
    单精度的小数,有效位数只有6-7位,超出了有效位数之后输出的就是垃圾数据
    双精度的小数,有效位数只有15-16位,超出了有效位数之后输出的就是垃圾数据
    有效位数是从小数点前面开始计算
    printf("%.*lf", 2, value) // *用作占位,会把2替换进去

    长度
    %hhi char
    %hi short int
    %li long int
    %lli long long int

scanf 
    如果接受的不是字符类型的数据,那么输入的空格,TAB,回车都会被忽略
    格式化字符串不能以\n结尾,否则永远无法结束
    格式化字符串中如果除了格式化字符串还有别的字符串,那么必须原样输入,否则接受的数据就不对
    如果需要同时接受多个非字符类型的数据,可以通过空格,TAB,回车作为分隔符

    scanf会先从输入缓冲区中获取数据,如果输入缓冲区没有数据,那么程序就会阻塞,等待用户输入
    如果用户输入了数据,scanf函数会将用户输入的数据放到输入缓冲区中,然后再从输入缓冲区获取数据
    如果输入缓冲区中已经有数据了,那么就不会要求用户输入数据,会直接从缓冲区中获取数据

    清空输入缓冲区
        1 scanf之后调用fflush(stdin),但是该方法只能在windows上使用
        2 setbuf(stdin, NULL),可跨平台

printf函数的返回值使我们打印了多少个字符

算数运算符
    结果的正负性取决于被除数的正负性

sizeof(变量|常量|数据类型) 或者 sizeof 变量|常量 // 获取变量占用的存储空间
sizeof是一个运算符,不是一个函数,优先级高于算数运算符

逗号运算符的运算结果是最后一个表达式的值, e.g.
int a, b, c;
a = 10, b = 20, c = 30;
int res = ((a + b), (a + c)) // 返回40

如果while或者if或者for省略了大括号,那么不能在后面直接定义变量
在企业开发中如果要判断是否相等,建议把常量写在前面,把变量写在后面
在企业开发中一定不要使用==来判断两个小数是否相等,因为小数可能出现精度问题,可以先转为字符串来比较

switch理论上性能比if高,但是if更适合多条件判断
switch中的defualt不论是否在switch语句的最后,都会最后执行
switch中只能放整形或者能被提升为整形的表达式或者变量或者常量
case后面只能放常量和表达式,并且必须是整形或者能够被提升为整形的
case中不能定义变量,除非加大括号,e.g.
case 1: {
    int num = 666;
    break;
}

c语言中的rand()函数返回的是一个伪随机数
如果真的要生成随机数需要在rand之前加上srand(time(NULL)),其实就是加一个seed

函数名称不能相同,即便形参列表或者返回值不同也不行
函数不能嵌套定义
函数内部不能定义和形参同名的变量

如果函数的定义写在了调用之后,必须在调用之前编写函数的声明,e.g.
void test();
函数的声明可以是多次的,实现只可以有一次，声明时可以不需指定形参的名称

int main(int argc, const char *argv[])
如果main返回的不是0代表告诉系统程序不是正常结束的
如果没有写函数的返回值类型,默认就是int类型
如果函数的返回值类型和实际返回的类型不同,那么会隐式转换为返回值类型

符号位0代表正数,1代表负数
正整数的源码,反码,补码都是它的2进制
负整数的反码除了符号位之外,0变1,1变0
补码等于反码加1
存储在计算机中的都是补码
^代表异或,相同为0,不同为1
任何两个相同的值异或之后的结果都是0,任何一个数和0异或之后的结果还是那个数
任何一个数异或另外一个数两次之后,还是那个数,该特性适合用于加密场景

一个数左移几位就是这个数乘以2的多少次幂
一个数右移几位就是这个数除以2的多少次幂
右移的规律就是除符号位以外整体右移,多出来的砍掉,缺少的用符号位填充

交换变量方式
a = a ^ b;
b = a ^ b;
a = a ^ b;

数组部分初始化
int ages[] = {[0] = 1, [3] = 3};
如果定义的同时不初始化,那么元素的个数不能省略
如果先定义再初始化,那么就不能一次性初始化,要一个一个元素赋值
如果定义的同时部分初始化,那么没有被初始化的元素会被赋值为0
如果先定义再部分初始化,那么没有被初始化的元素不会赋值为0
在定义数组时,数组的元素个数只能放常量或者常量表达式
数组名保存的是数组占用内存空间最小的那个地址
当数组作为函数参数时,没办法在函数内动态计算数组长度,因为地址必须用指针类型来接受,所以默认会被隐式转化为指针类型

排序
  1. 计数排序 通过预先创建好数组,将数字对应数字索引赋值,最后输出有赋值的索引即可
     计数排序只能用于有限数字并且不为负数的排序,但是效率是最高的
  2. 选择排序 一轮一轮排序,每次都用一个元素和后续所有元素比较,从左开始每轮算出一个最值
  3. 冒泡排序 一轮一轮相邻排序排序,每轮在右边会获取一个最值
  4. 插入排序 会从第一个元素开始,让第一个元素和前面一个元素比较
            如果满足条件,就让前面一个元素往后移动一位,继续再和前面一个进行判断
            直到前面没有元素可以比较或者和前面一个元素比较之后不满足条件为止
  5. 希尔排序 将数组按照指定步长分组,对分组的数组进行插入排序,在将排序后的数组合并为一个数组
            然后之后每轮都是将原步长除以2得到新步长在重复上面的排序动作
            和插入排序的区别就是插入排序步长一开始就为1,但是希尔排序是我们自己定义的
    
字符串是一个特殊的数组,如果想用数组来表示字符串,那么数组必须是char类型,并且最后一个元素必须是\0
char str[10] = {'l', 'n', 'j'} 是一个字符串,
因为在定义同时部分初始化,那么没有被初始化的元素会自动赋值为0
而\0在ASCII中就是0
char str4[] = "lnj" 背后就是{'l', 'n', 'j', '\0'}
puts(str) 会自动换行
scanf + %s 接受字符串,输入的数据中不能有空格\TAB\回车,系统会将上面3个符号当做结束符号
gets(str) 也用于接受字符串,但是可以接受空格\TAB
strlen(str) 计算字符串长度,不会算入结尾符
strcat(str1, str2) 拼接字符串,会直接修改第一个数组的内容,但是第一个数组必须空间足够容纳后面拼进去的数组才可以
strncat(str1, str2, count) 只拼接count个数的字符进入第一个数组
strcpy(dest, src) 会将src中的字符拷贝到dest中,覆盖掉dest中原有的内容,同样第一个数组必须空间足够容纳后面拼进去的数组才可以
strcmp(str1, str2) 字符串比较,如果大于,返回1，小于返回-1，等于返回0
定义字符串也可以使用指针方式 e.g. char *str = "lnj";

无论什么类型的指针变量在相同的编译器下占用的内容都相同,
32位编译器下4个字节,64位下8个字节,
指针为什么要有类型,是因为在获取指向变量中的数据时,指针是不知道要获取多少个字节的数据的,所以需要指明类型用来读取数据
多级指针其实就是指向指针的指针,几个*代表几级

利用指针保存数组的地址之后, p = ages = &ages
所以ages[8] = 0 等同于 p[8] = 0
在数组中可以利用指针变量加一的特性, e.g.
int *p = ages;
*(p + 1) 指针变量+1加的就是指针变量类型占用的字节数

利用数组和指针定义字符串的区别:
    1. 存储位置不同
        如果是通过数组定义的字符串,那么存储在内存的栈中
        如果是通过指针定义的字符串,那么存储在内存的常量区中
    2. 由于在内存中存储的位置不一样,所以特性也不一样
       如果是通过数组定义的字符串,我们是可以手动修改的
       如果是指针,不能手动修改
    3. 如果是通过数组定义的字符串,每次定义都会重新开辟存储空间
       如果是指针,重复定义不会重复开辟

接收字符串的时候,只能通过字符数组,不能通过字符指针
// 错误写法
char *str;
scanf("%s", str)

如果函数中返回的字符串是通过数组创建的,那么外界无法获取,通过指针就可以
原因就是因为前面说到的区别第3点
在函数结束时通过数组创建的就会被释放

函数名保存的就是函数的地址 
定义方式 e.g.
void (*funcP)(int, int);
funcP = &test; 或者 funcP = test;
(*funcP)(3, 4)

结构体3中初始化方式
    1. 先定义再初始化
        struct Dog dd;
        dd.name = "www"
    2. 定义同时初始化
        struct Dog dd = {"www", 1, 1.5};
    3. 不按顺序初始化
        struct Dog dd = {.age = 1, .name = "ww", .height = 1.5};

结构体可以在定义之后再完全初始化,数组不行
struct Dog dd;
dd = (struct Dog){"ww", 1, 1.5};

定义结构体同时定义变量 e.g.
struct Person {
    char *name
} p2;
也可以省略结构体名称(匿名结构体),这种情况下结构体类型只能使用一次
struct {
    char *name
} p2;

结构体变量的名称并没有保存结构体首属性的地址
结构体在分配内存的时候,会做一个内存对齐的操作
会按照结构体属性当中占用内存最大的那个属性的字节的倍数来分配
但是分配时会开辟最大属性字节的内存给第一个属性,如果分配给第一个属性之后还能继续分配第二个属性,那么就继续放入
如果分配给第一个属性之后,剩余的内存不够分配给第二个属性了,那么会再次开辟最大属性字节的内存，再次分配

struct Person per = {"lng"};
struct Person *p;
p = &per;
per.name == (*p).name == p->name

结构体变量之间的赋值和基本数据类型赋值一样,是拷贝

结构体的每个属性都会占用一块单独的内存空间,而共同体所有的属性都公用同一块存储空间
只要其中一个属性发生了改变,其他的属性都可能会收到影响
union Test {
    int age;
    char ch;
};
union Test t;
t.age = 33;

枚举(K + 类型名称 + 含义, 命名规范)
默认从0开始取值,也可以手动指定从几开始
enum Gender {
    KGenderMale = 9, // 手动指定从9开始
    KGenderMFemale,
}
p1.gender = male;
p2.gender = female;
定义枚举变量的方式同结构体

如果有多个同名的全局变量,那么也只会分配一次存储空间,多个同名的全局变量共用同一块存储空间,哪怕不是同一个文件中的也是
auto和register都用于修饰局部变量,修饰编程的存储特性
auto告诉编译器局部变量离开作用域就自动释放,但是其实默认就是auto的,所以这个修饰是废话
register告诉编译器将局部变量存储到CPU寄存器中,好处就是访问速度更快,但是不同平台,不同编译器下,会做不同的优化,所以即便写了也未必会放上去,所以还是一句废话
static对局部变量的作用,会将局部变量的存储区从栈区移到静态区,静态区只有程序结束才会释放
extern对全局变量的作用,用于声明一个变量,并不会开辟存储空间 e.g.
int main() {
    extern int num;
    num = 998;
    return 0
}
int num;
通过extern就可以骗过编译器,不会在编译时发生错误,当然后面还是要定义num这个全局变量的
static对全局变量的作用,定义一个内部的全局变量,该变量只能在定义的文件中使用,不能在其他文件中使用,并且该变量会独占一块内存空间
extern修饰函数,代表这是一个外部函数,其他文件中也可以使用,默认就是extern,所以是废话
static修饰函数,代表这是一个内部函数,只能在当前文件使用
extern和static对于函数的修饰必须写到函数实现中,写在声明中无效

编译过程
1. 将源文件编译成预处理文件(主要是将include,宏定义之类的拷贝进源文件或者做一些转换)
   gcc -E main.c -o main.i
2. 将预处理文件转化为汇编文件
   gcc -S main.i -o main.s
3. 将汇编文件转化为2进制文件
   gcc -C main.s -o main.o
4. 对二进制文件进行链接,生成可执行文件(主要是链接系统的库用来支持系统的函数,如printf等)
   gcc main.c
5. 运行可执行文件
   a.exe

预处理指令
1. 文件包含 include
    include <> 会先从编译器的环境中查找对应的文件,如果没有再从系统的环境中查找对应的文件
    include "" 会先从当前项目环境中查找对应的文件,如果没有再从编译器的环境中查找对应的文件,如果还没有再从系统的环境中查找对应的文件
    导入时函数的定义不可以重复,但是函数的声明可以重复
    如果函数的声明被include导入多次,那么会影响程序的编译效率,所以C语言中引入了一个头文件卫士的概念,用于解决重复导入 e.g.
    #ifndef DESMOND
    #define DESMOND
    int sum(int num1, int num2);
    #endif
    这样当重复导入时由于已经在宏中定义过了,就不会重复声明了
2. 宏定义 #define
   宏定义会在预处理的时候,用宏定义对应的值来替换宏
   不带参宏定义 #define 宏名称 宏值
   带参宏定义 #define 宏名称(参数) 宏的值 e.g.
        #define SUM(a, b) a+b
        如果函数的业务逻辑非常简单,建议使用宏定义
        因为效率更高,因为是在预处理时就执行了,而函数则是在运行时,宏定义只会做简单的替换,而函数还需要分配内存空间
        宏的值得每个参数都需要加上() e.g. #define PF(a) a * a 编译PF(2+2)就会得到错误结果,所以应该写成#define PF(a) (a) * (a)
        宏的值得结果也需要加上() e.g. #define JF(a) (a) + (a) 编译JF(5 + 5) / JF(2 + 2)就会得到错误结果,所以应该写成#define PF(a) ((a) * (a))
   宏定义后面不要加分号
   宏定义的作用域和全局变量很像,但是可以提前结束
    #define COUNT 666
    ...
    #undef COUNT
3. 条件编译 #if #else #elif #endif
    条件编译中不能获取变量的值
    因为变量是程序执行时才有的,而条件编译是预处理的时候就执行了
    所以条件编译一般是配合宏定义使用的
    #if #else中只有满足条件的语句才会编译到程序中
    第一种格式
    # if 0 == SCORE
        printf("0");
    # else
        printf('100")
    # endif
    第二种格式
    #ifdef DEBUG // 判断有没有定义某一个宏,#ifndef判断是不是没有定义某一个宏
        printf("开发阶段");
    #else
        printf("部署阶段");
    #endif

typedef 给数据类型起别名
typedef 原来类型名称 新的类型名称;
typedef int DESMOND;
typedef DESMOND DAI; // 可以给别名再起别名

typedef int (*funP)(int, int) // 给指向函数的指针起别名,这个case就不需要指定名字了,直接使用默认的funP
funP p1 = &sum;
funP p2 = &minus

const用于定义一个常量,定义之后数据就不可以修改了
const可以写在类型前面,也可以写在后面 e.g. int const num = 10 或者 const int num = 10
但是对于指针来说,写在不同位置就有区别了,写在数据类型前面和后面代表指针指向的内存空间不能修改,但是指针的指向可以修改
如果写在*后面,则指向的内存空间可以修改,但是指针的指向不可以改变

堆内存可以存放任意类型数据,但是需要自己申请和释放
堆大小理论上无穷大,但是实际受限于实际内存大小和内存是否连续性
int *p1 = (int *)malloc(sizeof(int)) // 手动申请一块堆内存,4字节
free(p1) // 手动释放我们申请的空间

malloc会返回一个void *,这是一个万能指针,可以转换为任意类型的指针
malloc使用 e.g.
int *p = (int *)malloc(3 * sizeof(int));
*(p + 0) = 1;
*(p + 1) = 3;
*(p + 2) = 5;
或者
p[0] = 1;
p[1] = 3;
p[2] = 5;
通过malloc申请的空间默认存储的是垃圾数据,也就是系统不会帮我们初始化
所以一般malloc都会和memset函数结合使用
memset专门用于初始化一块空间
memset(des, val, size) 
// dest需要初始化的内存地址
// val初始化的值
// size初始化多少个字节
e.g. memset(p, 0, 3 * sizeof(int))

calloc函数就是对malloc函数的封装,一般用于开辟数组的存储空间
int *p = (int *)calloc(3, sizeof(int)); // 开辟3块存储空间,每块存储空间占4个字节

realloc函数用于给内存扩容和缩容
利用malloc函数分配存储空间,必须是连续的,也就是在堆内存中分配内存空间必须是连续的
所以利用realloc函数扩容的时候,后面没有连续的内存的话,会分配一块新的内存
int *p1 = (int *)malloc(sizeof(int));
int *p2 = (int *)realloc(p1, sizeof(int) * 2);

链表是用来解决malloc或者开辟数组找不到连续的内存空间的问题的
如果指针没有值可以直接赋值为NULL,明确告诉系统该指针没有值
如果一个指针没有值,也没有赋值NULL,那么这个指针就是一个野指针
一定不要操作没有值得指针和野指针
静态链表
    typedef struct node {
        int data;
        struct node *next;
    } Node;

    Node a;
    Node b;
    Node c;

    a.data = 1;
    b.data = 3;
    c.data = 5;
    a.next = &b;
    b.next = &c;
    c.next = NULL;
    Node *head = &a;
    静态列表比较少用,因为不能动态分配
空链表
    头指针指向一个空链接节点,该节点没有数据也没有指向任何节点
动态链表
    1. 尾插法
        1 让新节点的下一个节点等于头结点的下一个节点
        2 让头结点的下一个节点等于新节点
    2. 头插法
        1 定义变量(pre)记录新节点的上一个节点
        2 将新节点添加到上一个节点后面
        3 让新节点成为下一个节点的上一个节点(将pre指向新节点)

文件分类
    1. 文本文件 以ASCII码存储的
    2. 二进制文件

    文本文件存储的时候,会先查询需要存储数据的ASCII码,然后再将对应的ASCII码转化为二进制,然后再存储
    二进制文件在存储的时候,会直接转换成二进制存储
    从存储的步骤来看,文本文件需要先查找在存储,所以效率会低一些
    从内存的表现来看,文本会更占用内存

fopen 文件打开
    FILE *fp = fopen("a.txt", "r");
    if (fp == NULL) {
        printf("打开失败");
    }

    模式中r+和w+的区别在于r+如果文件不存在就会报错,但是w+会创建文件

fclose 文件关闭
    fclose(fp); // 成功返回0,失败返回EOF(即-1)

fputc 往文件中写入一个字符
    fputc('a', fp); // 成功返回写入的字符,失败返回EOF

fgetc 一次读一个字符
    // 如果写入之后,文件指针会停在当前写入的位置,所以要读取前面的话需要调用rewind
    // 失败返回EOF
    char ch = fgetc(fp); 

rewind(fp); // 将文件指针重新指向一个流的开头

feof(fp) // 文件末尾判断,0代表未到末尾,非0代表到末尾,开发中不推荐使用,直接使用EOF

fputs写入字符串,遇到\0会停止
fputs("aaa", fp) // 一次写入一堆字符

char buf[5];
// 读取一行的数据,遇到\n就会自动终止读取
// 每次只能读取n-1个字符,会在末尾自动添加\0
// 遇到EOF也会自动停止读取
fgets(buf, 4, fp); // 返回str指针,出错或遇到文件结尾返回空指针NULL

fwrite和fread用于操作二进制文件
int num = 123456;
// 第一个参数: 需要写入文件的数据地址
// 第二个参数: 每次写入多少个字节
// 第三个参数: 需要写入多少次
// 第四个参数: 被写入文件的句柄
由于二进制中没有\n \0这些概念,所以写入的时候不会受到它们的影响
fwrite(&num, sizeof(int), 1, fp); // 用于一次性写入一块数据

fwrite在写入指针类型属性的时候,写入的是属性保存的地址
所以一般会将指针类型专用数组 e.g. char *name 转为 char name[8]

char buf[1024] = {0};
fread(buf, 1024, 1, fp) // 一次性读取一块数据,返回0代表读取错误



