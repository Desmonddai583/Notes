函数直接或者间接调用自身就是递归
递归需要有边界条件、递归前进段、递归返回段
递归一定要有边界条件
当边界条件不满足的时候，递归前进
当边界条件满足的时候，递归返回

递归要求
  递归一定要有退出条件，递归调用一定要执行到这个退出条件。没有退出条件的递归调用，就是无限调用
  递归调用的深度不宜过深
    Python对递归调用的深度做了限制，以保护解释器
    超过递归深度限制，抛出RecursionError： maxinum recursion depth exceeded 超出最大深度
    sys.getrecursionlimit() # cpython默认1000层

递归的性能
  循环稍微复杂一些，但是只要不是死循环，可以多次迭代直至算出结果
  以斐波那契为例,fib函数代码极简易懂，但是只能获取到最外层的函数调用，内部递归结果都是中间结果。而且给定一个n都要进行近2n次递归，深度越深，效率越低。
  为了获取斐波那契数列需要外面在套一个n次的循环，效率就更低了
  递归还有深度限制，如果递归复杂，函数反复压栈，栈内存很快就溢出了

fib改进
  def fib(n, pre=0, cur=1):
    pre, cur = cur, pre + cur
    if n == 0:
      return pre 
    return fib(n-1, pre, cur) 
  fib(n)

  和循环的思想类似
  参数n是边界条件，用n来计数
  上一次的计算结果直接作为函数的实参
  效率很高
  和循环比较，性能相近(不过还是差一些,因为栈帧中创建函数需要消耗一些性能)。所以并不是说递归一定效率低下。但是递归有深度限制

间接递归
  def foo1():
    foo2()
  def foo2():
    foo1()
  间接递归，是通过别的函数调用了函数自身
  但是，如果构成了循环递归调用是非常危险的，但是往往这种情况在代码复杂的情况下，还是可能发生这种调用。要用代码的规范来避免这种递归调用的发生

递归总结
  递归是一种很自然的表达，符合逻辑思维
  递归相对运行效率低，每一次调用函数都要开辟栈帧
  递归有深度限制，如果递归层次太深，函数反复压栈，栈内存很快就溢出了
  如果是有限次数的递归，可以使用递归调用，或者使用循环代替，循环代码稍微复杂一些，但是只要不是死循环，可以多次迭代直至算出结果
  绝大多数递归，都可以使用循环实现
  即使递归代码很简洁，但是能不用则不用递归
