冒泡法
  属于交换排序
  两两比较大小，交换位置。如同水泡咕嘟咕嘟往上冒
  结果分为升序和降序排列

  升序
    n个数从左至右，编号从0开始到n-1，索引0和1的值比较，如果索引0大，则交换两者位置，如 果索引1大，则不交换。
    继续比较索引1和2的值，将大值放在右侧。直至n-2和n-1比较完，第一轮比较完成。
    第二轮从索引0比较到n-2，因为最右侧n-1位置上已经是最大值了。依次类推， 每一轮都会减少最右侧的不参与比较，直至剩下最后2个数比较。
  
  降序
    和升序相反

  总结
    冒泡法需要数据一轮轮比较
    可以设定一个标记判断此轮是否有数据交换发生，如果没有发生交换，可以结束排序，如果发生交换，继续下一轮排序
    最差的排序情况是，初始顺序与目标顺序完全相反，遍历次数1,...,n-1之和n(n-1)/2
    最好的排序情况是，初始顺序与目标顺序完全相同，遍历次数n-1
    时间复杂度O(n2)

选择排序
  简单选择排序
    属于选择排序
    两两比较大小，找出极值(极大值或极小值)放置在固定的位置，这个固定位置一般指的是某一端
    结果分为升序和降序排列
  降序
    n个数从左至右，索引从0开始到n-1，两两依次比较，记录大值索引，此轮所有数比较完毕，将 
    大数和索引0数交换，如果大数就是索引1，不交换。第二轮，从1开始比较，找到最大值，将它 
    和索引1位置交换，如果它就在索引1位置则不交换。依次类推，每次左边都会固定下一个大数。
  升序
    和降序相反

  二元选择排序(优化实现)
    同时固定左边最大值和右边最小值
    减少迭代元素的次数
    如果一轮比较后，极大值、极小值的值相等，说明比较的序列元素全部相等,可以结束排序
    [1, 1, 1, 1, 1, 1, 1, 1, 2] 这种情况，找到的最小值索引是-2，最大值索引8，上面的代码会交换2次，最小值两个1交换是无用功，所以，增加一个判断
  
  总结
    简单选择排序需要数据一轮轮比较，并在每一轮中发现极值
    没有办法知道当前轮是否已经达到排序要求，但是可以知道极值是否在目标索引位置上
    遍历次数1,...,n-1之和n(n-1)/2
    时间复杂度O(n2)
    减少了交换次数，提高了效率，性能略好于冒泡法
 
 插入排序
  直接插入排序原理
    在未排序序列中，构建一个子排序序列，直至全部数据排序完成
    将待排序的数，插入到已经排序的序列中合适的位置
    增加一个哨兵，放入待比较值，让它和后面已经排好序的序列比较，找到合适的插入点

    最好情况，正好是升序排列，比较迭代n-1次
    最差情况，正好是降序排列，比较迭代1,2,...,n-1即 n(n-1)/2
    使用两层嵌套循环，时间复杂度O(n^2)
    稳定排序算法
      稳定排序指的是出现相同值时,排序之后的顺序还是跟原本一样
    使用在小规模数据比较
    优化
      如果比较操作耗时大的话，可以采用二分查找来提高效率，即二分查找插入排序
  