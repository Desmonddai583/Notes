go中的数组可以先定义再一次性初始化(C语言不行)
    var ages [3]int
    ages = [3]int{1, 3, 5}
定义同时初始化
    1. 完全初始化
        var ages [3]int = [3]int{1, 3, 5}
    2. 部分初始化
        var ages [3]int = [3]int{1, 3}
    3. 指定元素初始化
        var ages [3]int = [3]int{2:5} //给下标为2的元素赋值5
   定义同时初始化可以省略元素个数
        ages := [...]int{1, 3, 5}
        

数组在go语言中是一个值类型,所以数组之间的赋值是拷贝关系,而不是指向的关系
如果想让两个数组可以互相赋值,那么两个数组的类型必须一致
类型一致包括元素个数,元素个数也是Go中数组类型的一部分
如果数组中存储的元素类型支持==, ！=操作, 并且两个数组的类型是一样的, 那么数组也支持==, !=操作

二维数组也可以省略元素个数,但是只能省略行数,不能省略列数(新版本也可以省略列数)

ages := []int{1, 3, 5} // 代表切片
只要数组的[]中没有编写数字,那么就不是一个数组,是一个切片
切片不支持== !=操作 (相同维数且含有相同个数元素的数组才可以⽐较,每个元素都相同的才相等)
创建切片
    1. 通过数组创建
        var ages [5]int = {1, 3, 5, 7, 9}
        var sce []int = ages[0:2] // 不包括结束位置下标
        指定数组的索引初始化切片，是数组的引用
        len(sce) // 计算切片当前保存数据的个数
        cap(sce) // 计算切片总共可以保存数据的个数,等于数组的长度减去起始位置
        如果只写了起始位置,没有写结束位置,会截取到最后
        如果只写了结束位置,没有写起始位置,会从开始截取到指定的结束位置
        如果只写了:,那么就是从开始截取到结尾
        数组创建切片还可以使用 数组名称[low:high:max]
        注意max必须大于或等于high,如果指定了第三个参数,那么切片的容量就等于第三个参数减去第一个参数
    2. 通过make函数创建
        var sce []int = make([]int, 2, 5)
        第三个参数cap可以省略,如果省略,cap的容量就等于len(第二个参数)
    3. 通过go提供的语法糖创建(len等于cap)
        var sce []int = []int{1, 3, 5}

切片在未初始化之前默认为 nil，长度为0，可以通过s == nil进行判断
    
切片作为函数的参数,是地址传递(指针),在函数内修改形参,会影响到函数外的实参
如果定义了一个切片没有初始化,不可以使用下标赋值的方式赋值,数组可以
如果像使用数组一样使用切片,那么索引的长度不能超过切片的len
append(切片, 数据) // 在len后面追加数据
如果通过append函数追加后超过了原有的容量,那么会自动按照当前容量*2的方式重新定义一个数组作为切片保存数据的模型
这里注意如果容量小于1024的时候扩容,会按照2倍,但是当超过1024之后,会按照0.25倍扩容
append函数要返回一个切片的原因是因为在扩容的时候会重新定义一个新的切片,所以要返回一个切片

copy(目的切片, 源切片) 
拷贝时会以目标切片为主,所以只会拷贝目的切片长度的数据如果源切片长度大于目的切片,
如果目的切片长度大于源切片那么就覆盖掉源切片长度的值,剩下的依旧使用目的切片的值

删除切片中的元素
    index := 2
    sce = append(sce[:index], sce[index + 1:]...)

直接打印切片的变量名代表获取切片中数组指针保存的位置
    var sce []int = arr[:]
    fmt.Printf("%p", sce)

可变参数,底层就是一个切片,并且可变参数只能放在函数形参列表的最后
    sum(10, 20, 30)
    func sum(num ...int) int {
        ...
    }
    背后其实就等于是
    func sum(nums []int) int {
        ...
    }